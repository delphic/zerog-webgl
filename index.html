<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<title>Gremlin Test Index</title>
		<script type="text/javascript" src="libs/jquery-1.6.1.min.js"></script>
		<script type="text/javascript" src="libs/glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="libs/webgl-utils.js"></script>
		<!-- Shaders -->
		<script id="vertex-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			uniform vec4 uColor;
			uniform bool uUseTextures;
			uniform sampler2D uSampler;

			void main(void) {
				if(uUseTextures) {
					vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
					gl_FragColor = vec4(textureColor.rgb * uColor.rgb * vLightWeighting, textureColor.a); // TODO: think about how to use, uColor alpha and if we should
				}
				else {
					gl_FragColor = vec4(uColor.rgb * vLightWeighting, uColor.a);
				}
			}
		</script>
		<script id="vertex-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform bool uUseLighting;
			
			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			void main(void) {
				vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * mvPosition;
				vTextureCoord = aTextureCoord;
				
				if(!uUseLighting) {
					vLightWeighting = vec3(1.0, 1.0, 1.0);
				}else {
					vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
					
					// Point Lights
					// TODO: Investigate using just vertexposition instead of mvPosition and not transforming the normals
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - mvPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - mvPosition.xyz);
						float pointLightWeighting = max(dot(transformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						// Check if position in the cone
						float angleToMv = acos(dot((mvPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - mvPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightThi[i]);
						}
						else {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightTheta[i]);
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
					
					vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				}
			}
		</script>
		<script id="pixel-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			uniform vec4 uColor;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform float uMaterialShininess;
			
			uniform bool uUseLighting;
			uniform bool uUseSpecular;
			
			uniform bool uUseTextures;

			uniform sampler2D uSampler;


			void main(void) {
				vec3 lightWeighting;
				if (!uUseLighting) {
					lightWeighting = vec3(1.0, 1.0, 1.0);
				} else {
					// For Specular Lighting
					vec3 eyeDirection = normalize(-vPosition.xyz);
				
					// Point Lights
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - vPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - vPosition.xyz);
						float pointLightWeighting = max(dot(vTransformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						// Specular
						float specularLightWeighting = 0.0;
						if (uUseSpecular) {
							vec3 reflectionDirection = reflect(-pointLightDirection, vTransformedNormal);
							specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
						}
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting + uPointLightingColor[i] * specularLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						float specularLightWeighting = 0.0;
						// Check if position in the cone
						float angleToMv = acos(dot((vPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - vPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightThi[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						else {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightTheta[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting + uSpotLightColor[i] * specularLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(vTransformedNormal, uLightingDirection), 0.0);
					
					lightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				} 
				if(uUseTextures) {
					vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
					gl_FragColor = vec4(textureColor.rgb  * uColor.rgb * lightWeighting, textureColor.a);
				}
				else {
					gl_FragColor = vec4(uColor.rgb * lightWeighting, uColor.a);
				}
			}
		</script>
		<script id="pixel-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			void main(void) {
				vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * vPosition;
				vTextureCoord = aTextureCoord;
				vTransformedNormal = normalize(uNMatrix * aVertexNormal);
			}
		</script>
		<!-- Gremlin Engine -->
		<script type="text/javascript" src="Gremlin.js"></script>
		<!-- GUI : Note JQuery Depedency -->
		<script src="GUI.js"></script>
		<!-- Game Script -->
		<script type="text/javascript">
function _Game() {
	// TODO: Change naming to public / private functions...
	var canvas;
	var	resolutionScale;
	var lastTime = 0;
	var gameState;
	
	var loadingTargetState;
	var assetsLoading = false; // for quick and dirty loading system - asset counter in the engine.
	function setLoading(val) {
		assetsLoadings = val;
	}

	// Game State Functions
	function updateGameState(val) {
		gameState = val;
	}
	
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
			
			// Animate Objects
			for(object in gameObjects)
			{
				gameObjects[object].animate(elapsed);
			}
			
			if(gameState == "InGame") {
				// TODO: Collision Checks and AI (should possibly be run every X frames)
			
				// Update Player Reserves - TODO move to functions on player / player ship object
				if(player.shield < 100) { player.shield += elapsed*player.shieldRegen; if(player.shield>100) player.shield = 100; } 
				if(player.energy < 100) { player.energy += elapsed*player.energyRegen; if(player.energy>100) player.energy = 100; }
				if(player.fuel < 100) { player.fuel += elapsed*player.fuelRegen; if(player.fuel>100) player.fuel = 100; }
				
			
				// Handle Game Input
				// BUG: Keys get 'stuck down'
				var width = parseInt(canvas.style.width, 10);
				var height = parseInt(canvas.style.height, 10);
				var mousePos, lmbDown, rmbDown;
				mousePos = GremlinInput.getMousePos();
				lmbDown = GremlinInput.mouseDown(0);
				rmbDown = GremlinInput.mouseDown(2);
				
				var dyaw, dpitch, droll, dx, dz;
				dyaw = 0.05 * elapsed * ((width*0.5)-mousePos[0])/(0.5*width);
				dpitch = 0.05 * elapsed * ((height*0.5)-mousePos[1])/(0.5*height);
				droll = 0;
				if (GremlinInput.keyDown("q")) { droll += 0.1 * elapsed; }
				if (GremlinInput.keyDown("e")) { droll -= 0.1 * elapsed; }
				if (rmbDown) Gremlin.rotatePlayerCamera(dyaw, dpitch, droll);
				else if (GremlinInput.keyDown("q") || GremlinInput.keyDown("e")) { Gremlin.rotatePlayerCamera(0, 0, droll); }

				// Pew Pew
				if(lmbDown) {
					if (player.firingTimer >= 300 && player.energy > player.projectileEnergyCost) { // TODO: implement link between high energy reserves and rate of fire
						var pos = [0,0,0];
						Gremlin.playerCameraPos(pos); // Note setting equal to player.position cause updating the camera as well as the projectiles! TODO: put player in an object / namespace rather than store as an array to remove this temptation!
						// TODO: Also this needs to be turret attach point rather than camera position
						var aimtAt = [0,0,0];
						aimAt = Gremlin.pickPosition(mousePos[0], mousePos[1], 500); // 500 should be replaced by distance to target
						var v = [0,0,0]; 
						vec3.subtract(aimAt, pos, v);
						vec3.normalize(v);
						vec3.scale(v,1);
						vec3.add(v,player.velocity);
						
						var newproj = new projectile(pos, v, 10, 30000, true);

						projectiles.push(newproj);
						player.firingTimer = 0;
						player.energy -= player.projectileEnergyCost; 
					}
					else {
						player.firingTimer += elapsed;
					}
				}
				
				var accelRate = 0.005; // TODO: Move to player object
				if(player.fuel > 90) { accelRate  *= 1.2; }
				else if (player.fuel < 10) { accelRate *= 0.8; }

				dx = 0;
				dz = 0;

				if (GremlinInput.keyDown("Left") || GremlinInput.keyDown("a")) {
					// Strafe Left
					dx -= accelRate * elapsed;
				} 
				else if (GremlinInput.keyDown("Right") || GremlinInput.keyDown("d")) {
					// Strafe Right
					dx += accelRate * elapsed;
				}

				if (GremlinInput.keyDown("Up") || GremlinInput.keyDown("w")) {
					// Move Forward
					dz -= accelRate * elapsed;
				} 
				else if (GremlinInput.keyDown("Down") || GremlinInput.keyDown("s")) {
					// Move Backward
					dz += accelRate * elapsed;
				}
				
				if(dx && dz) { // Clamp Diagonal Speed
					dx /= 1.41421;
					dz /= 1.41421;
				}
			
				var dvelocity = [(0.01*dx/player.mass), 0, (0.01*dz/player.mass) ];
				Gremlin.playerCameraReverseRotation(dvelocity);
				
				if (player.fuel > 0 && (dx != 0 || dz != 0)) {
					player.velocity[0]+=dvelocity[0];
					player.velocity[1]+=dvelocity[1];
					player.velocity[2]+=dvelocity[2];
					player.fuel-=elapsed*player.fuelCost;
				}
				
				Gremlin.setPlayerCamera(player.position[0]+player.velocity[0],player.position[1]+player.velocity[1],player.position[2]+player.velocity[2]); // !!! TODO: Ooops - is not independant of frame rate!
				
				Gremlin.playerCameraPos(player.position);
				
				if (GremlinInput.keyDown("Esc")) {
					updateGameState("InMenu");
					pause();
					GremlinGUI.pause();
				}
			}
			
			// Update HUD
			GremlinHUD.setHudValues(player.health, player.shield, player.fuel, player.energy);
			
			// Update Motes
			updateMotes(player.position, player.velocity); //TODO: Needs to take elapsed in order to be indepedant of frame rate
			
			// Update Projectiles
			for(var i = 0; i < projectiles.length; i++) {
				// Update Lifetime
				projectiles[i].lifetime -= elapsed;
				// Despawn if lifetime has expired
				if (projectiles[i].lifetime < 0) {
					projectiles.splice(i,1);
				}
				else {
					// Update Position
					projectiles[i].updatePosition();  //TODO: Needs to take elapsed in order to be indepedant of frame rate
				}
			}
			
        }
        lastTime = timeNow;
    }

    function tick() {
        if(controller.isRunning()) { requestAnimFrame(tick); }
		
		if(gameState == "Loading") {
			// Wait for all assets to load
			if(assetsLoading) return;
			else gameState = loadingTargetState;
		}
		
		// Show / Hide HUD
		if(gameState == "InGame") { GremlinHUD.showHud(); }
		else { GremlinHUD.hideHud(); }
		
		// Render Scene
		Gremlin.prepareScene();
		for(object in gameObjects)
		{
			if(gameObjects[object].visible) {
				Gremlin.renderObject(gameObjects[object]);
			}
		}
		for(var i = 0; i < dustMotes.length; i++)
		{
			// Note: Not an efficient method of rendering particles...
			// We can get away with this because it's only ~100 objects
			Gremlin.renderObject(dustMotes[i]);
		}
		for(var n = 0; n < projectiles.length; n++)
		{
			var position = [0,0,0];
			position = projectiles[n].getPosition();
			projectileObject.setPosition(position[0], position[1], position[2]);
			Gremlin.renderObject(projectileObject);
		}
		
		// Animate Scene
        animate();
    }

	// Game Objects
	var gameObjects = [];
	var gamePointLights = [];
	var gameSpotLights = [];
	
	// Game Object Obj
	function gameObject(x,y,z) {
		this.x = x;
		this.y = y;
		this.z = z;
		
		this.rotation = mat4.create();
		mat4.identity(this.rotation);
		
		this.buffers = [];
		this.scale = [1, 1, 1];
		// TODO: Proper Material System?
		// TODO: Make into array for multiple texture IDs
		this.texture;
		this.color = [1.0,1.0,1.0,1.0];
		this.setColor = setColor;
		this.useLighting = true;
		this.setUseLighting = setUseLighting;
		this.shininess = 0;
		this.setShininess = setShininess;
		
		this.isSkyBox = false;
		this.setIsSkyBox = setIsSkyBox;
		
		this.move = move;
		this.setPosition = setPosition;
		this.rotate = rotate;
		this.setRotation = setRotation;
		this.setScale = setScale;
		this.animate = defaultAnimation;
		this.assignBuffer = assignBuffer;

		// Render Flags
		// Consider: Moving to Renderer
		this.visible = true;
		this.wireframe = false;
		this.points = false; // TODO: Combine this and wireframe into a render type (triangles / lines / points etc)
		this.useIndices = false;
		this.useTextures = false;
		
		function setPosition(x,y,z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}
		function move(dx, dy, dz) {
			this.x += dx;
			this.y += dy;
			this.z += dz;
		}
		function rotate(amount, X, Y, Z) {
			mat4.rotate(this.rotation, Gremlin.degToRad(amount), [X, Y, Z]);
		}
		function setRotation(yaw, pitch, roll) {
			mat4.identity(this.rotation);
			mat4.rotate(this.rotation, Gremlin.degToRad(yaw), [0,1,0]);
			mat4.rotate(this.rotation, Gremlin.degToRad(pitch), [1,0,0]);
			mat4.rotate(this.rotation, Gremlin.degToRad(roll), [0,0,0]);
		}
		function setScale(x,y,z) { this.scale = [x,y,z]; }
		function setColor(r,g,b,a) { this.color = [r,g,b,a]; }
		function setUseLighting(val) { this.useLighting = val; }
		function setShininess(val) { this.shininess = val; }
		
		function setIsSkyBox(val) { this.isSkyBox = val; if(this.isSkyBox) this.useLighting = false; } 
		
		function defaultAnimation() { /* Blank */ }
		function assignBuffer(index) {
			this.buffers = index;
		}
	}
	
	// Creation Objection
	function createObjectPrimitive(position, primType, textureName, scale, latBands, longBands, animation, shininess, isSkyBox) {
		var object = new gameObject(position[0], position[1], position[2]);
		var textured;
		if (textureName) { 
			textured = true;
		}
		else {
			textured = false;
		}
		if(scale.length) {
			object.setScale(scale);
		}
		else {
			object.setScale(scale,scale,scale);
		}
		switch(primType) {
		// TODO: Remove Size
		case "pyramid":
			Gremlin.createPyramid(object, textured);
			break;
		case "cube": 
			Gremlin.createCube(object, textured);
			break;
		case "sphere":
			Gremlin.createSphere(object, textured, latBands, longBands);
			break;
		case "ray":
			Gremlin.createRay(object);
			break;
		case "point":
			Gremlin.createPoint(object);
			break;
		default:
			alert("Invalid Prim Type: "+primType+"");
			return;
		}
		// TODO: Move to separate texture list and just assign appropriate index
		if(textured) {
			object.texture = Gremlin.createTexture(textureName);
		}
		if(shininess) {
			object.setShininess(shininess);
		}
		if(isSkyBox) {
			object.setIsSkyBox(true);
		}
		if(animation) {
			object.animate = animation;
		}
		gameObjects.push(object);
	}

	function createObjectModel(position, modelName, textureName, scale, animation, shininess) {
		var object = new gameObject(position[0], position[1], position[2]);
		var textured;
		if (textureName) { 
			textured = true;
		}
		else {
			textured = false;
		}
		if(scale.length) {
			object.setScale(scale);
		}
		else {
			object.setScale(scale,scale,scale);
		}
		Gremlin.loadModel(object, modelName);
		if(textured) {
			object.texture = Gremlin.createTexture(textureName);
		}
		if(shininess) {
			object.setShininess(shininess);
		}
		if(animation) {
			object.animate = animation;
		}
		gameObjects.push(object);
	}
	// Game Init
	function gameInit() {
		assetsLoading = false;
		
		// TODO: Player Init
		
		// TODO: Projectile Init
		// Create Projectiles
		Gremlin.createPyramid(projectileObject, false);		// TODO: Tumbling Tetrahedron would be better
		projectileObject.setScale(0.01,0.01,0.01);
		
		loadLevel("menu.js", "InMenu");
	}

	// Player / Ships
	var player = [];
	player.position = [0,0,0];
	player.velocity = [0,0,0];
	player.firingTimer = 1000;
	player.mass = 1;
	player.health = 100;
	player.shield = 100;
	player.energy = 100;
	player.fuel = 100;
	player.shieldRegen = 0.0025;
	player.energyRegen = 0.01;
	player.fuelRegen = 0.0075;
	player.projectileEnergyCost = 5;
	player.fuelCost = 0.015;

	// Enemies 
	// WRONG : This is too literal, I've written some of this code once already for player updating, need to refactor this into a better structure
	// TODO: multiple types
	function enemy(x,y,z) {
		this.shipObj = new GameObject(x,y,z);
		Gremlin.createCube(this.shipObj, false);
		
		this.velocity = [0,0,0];
		this.firingTimer = 0;
		this.health = 100;
		this.shield = 100;
		this.shieldRegen = 0.0025;
		
		this.update = update;
		// Might need this._updatePosition etc - yes we do
		
		// Presumably we need to add an set of interfaces for the gameObject (or can we access those directly?) - no we don't
		
		function update(elapsed) {
			_shieldRegen(elapsed);
			_updatePosition(elapsed);
		}
		function _updatePosition(elapsed) {
			this.shipObj.move(this.velocity[0],this.velocity[1],this.velocity[2]);
		}
		function _shieldRegen(elapsed) {
			if(this.shield < 100) { 
				this.shield += this.shieldRegen * elapsed; 
				if(this.shield > 100) {
					this.shield = 100;
				}
			}
		}
		
	}
	
	// Basic Projectile System
	var projectiles = [];
	var projectileObject = new gameObject(0,0,0);
	projectileObject.rotate(90, 1, 0, 0)
	projectileObject.setColor(5.0,0,0,1);
	projectileObject.setUseLighting(false); //TODO: Would be better with lighting true and emissive material
		
	function projectile(position, velocity, dmg, lifetime, friendly) {
		this.position = position;
		this.velocity = velocity;
		this.dmg = dmg;
		this.lifetime = lifetime;
		this.friendly = friendly;
		
		this.getPosition = getPosition;
		this.updatePosition = updatePosition;
		
		function getPosition() {
			return this.position;
		}
		function updatePosition() {
			this.position[0] += this.velocity[0];
			this.position[1] += this.velocity[1];
			this.position[2] += this.velocity[2];
		}
	}
	
	// Dust Motes
	var dustMotes = [];
	var maxMotes, randomFactor, rootThree;
	rootThree = 1.73205; // Approximately
	randomFactor = 10; // To Be Adjusted
	maxMotes = 100; // To Be Adjusted
	
	function createMotes() {
		for(var i = 0; i < maxMotes; i++) {
			var obj = new gameObject(2*randomFactor*(Math.random()-0.5), 2*randomFactor*(Math.random()-0.5), 2*randomFactor*(Math.random()-0.5));
			Gremlin.createPoint(obj);
			obj.points = true;
			obj.useLighting = false; // If we want the motes to be lit properly we'll have to figure out the normal to a point!
			obj.setColor(0.8,0.8,0.8,1);
			dustMotes.push(obj); 
		}
	}
 
	function updateMotes(pos, vel) {
		if (vec3.length(vel)) {
			for(var i = 0; i < dustMotes.length; i++){
				var boundingR;
				var posDiff = vec3.create();
				boundingR = vec3.length(vel) + rootThree*randomFactor;
				vec3.subtract(pos,[dustMotes[i].x, dustMotes[i].y, dustMotes[i].z], posDiff); 
				if (vec3.length(posDiff) >  boundingR) {
					// Respawn on opposite site of sphere 
					dustMotes[i].setPosition(
						pos[0] + 0.99*posDiff[0],
						pos[1] + 0.99*posDiff[1],
						pos[2] + 0.99*posDiff[2]
					);
				}
			}
		}
	}
	
	// WebGL Start
	
    function webGLStart(resScale) {
		canvas = document.getElementById("gremlinCanvas");
		resolutionScale = resScale;
		setCanvasSize();
		
		// Initialise
		Gremlin.init();
		gameInit();
		
		// Start Game Loop
        tick();
		
    }
	
	// Controller Bar
	
	function _controller() {
		var running = true;
		var windowPaused = false;
		
		function handlePause() { 
			if(running) { 
				_pause();
			} 
			else { 
				_unpause();
			}
		}
		
		function handleUnpause() {
			if(!running) {
				_unpause();
			}
		}
		
		function handleWindowBlur() {
			if(running) {
				windowPaused = true;
				_pause();
			}
		}
		
		function handleWindowFocus() {
			if(windowPaused) {
				windowPaused = false;
				_unpause();
			}
		}
		function isRunning() { return running; }
		function _pause() { running = false; }
		// TODO: if/when the game timer moves to an object adjust this		
		function _unpause() { running = true; lastTime = new Date().getTime(); requestAnimFrame(tick); }
		
		return { 
			isRunning: isRunning, 
			handlePause: handlePause, 
			handleUnpause: handleUnpause,
			handleWindowBlur: handleWindowBlur, 
			handleWindowFocus: handleWindowFocus 
		};
	}
	var controller = _controller();
	
	function pause() {
		controller.handlePause();
	}
	function unpause() {
		controller.handleUnpause();
	}
	function applyOptions(resScale, _lighting, _lightingType, _specularLighting) {
		resolutionScale = resScale;
		setCanvasSize();
		Gremlin.setLightingFlags("lighting", _lighting);
		Gremlin.setLightingFlags("specularLighting", _specularLighting);
		Gremlin.setShader(_lightingType);
	}
	function setCanvasSize() {
		if (resolutionScale) {
			canvas.width = resolutionScale*document.width;
			canvas.height = resolutionScale*window.innerHeight;
		}
		else {
			canvas.width = document.width;
			canvas.height = window.innerHeight;
		}
		canvas.style.width = document.width+"px";
		canvas.style.height = window.innerHeight+"px";
	}
	
	GremlinEventHandler.bindEvent("onblur", controller.handleWindowBlur);
	GremlinEventHandler.bindEvent("onfocus", controller.handleWindowFocus);
	GremlinEventHandler.bindEvent("onresize", setCanvasSize);
	GremlinEventHandler.bindEvent("onresize", Gremlin.resize);
	
	function loadLevel(fileName, targetState) {
		// Reset Player Object - should be method on player
		Gremlin.setPlayerCamera(0,0,0);
		Gremlin.setPlayerCameraRotation(0,0,0);
		player.position = [0,0,0];
		player.velocity = [0,0,0];
		player.firingTimer = 1000;
		// End Reset Player 
		gameState = "Loading";
		loadingTargetState = targetState;
		var fileref=document.createElement('script');
		fileref.setAttribute("type","text/javascript");
		fileref.setAttribute("src", fileName);
		if (typeof fileref!="undefined") document.getElementsByTagName("head")[0].appendChild(fileref);
	}
	function unloadLevel() {
		gameObjects.splice(0, gameObjects.length);
		projectiles.splice(0, projectiles.length);
		dustMotes.splice(0, dustMotes.length); // Looks like we need a level manager! ;D
		Gremlin.removeLights();
	}
	
	
	return {
		createObjectPrimitive: 		createObjectPrimitive,
		createObjectModel: 			createObjectModel,
		createMotes:				createMotes,
		setLoading:  				setLoading,
		updateGameState: 			updateGameState,
		loadLevel: 					loadLevel,
		unloadLevel:				unloadLevel,
		applyOptions:				applyOptions,
		pause:						pause,
		unpause:					unpause,
		webGLStart: 				webGLStart
	}
}
var Game = _Game();
		</script>
		<style>
			html, body { margin: 0; padding: 0; overflow: hidden; font-family: monospace; }
			canvas { display: block; margin: 0 auto; /*cursor: url('data:image/gif;base64,R0lGODlhAQABAPAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto; */ cursor: crosshair; }
			/* CSS Styles*/
			#menuContainer { color: #FFF; margin: 0 auto; position: absolute; z-index: 100; }
			#menuContainer div.menu { margin: 0 2.5%; }
			#menuContainer ul { list-style: none; padding: 0; }
			#menuContainer ul li { margin: 0.5em 0;}
			#menuContainer ul li a { cursor: pointer; color: #FFF; }
			#menuContainer a { color: #ACF; }
			#menuContainer select, #menuContainer input { background-color: #000; color: #FFF; border: none; font-size: 0.8em; font-family: monospace; }
			#menuContainer input[type=button] { margin: 0.5em 0; color: #ACF; cursor: pointer; }
			#menuContainer div.small { font-size: 0.5em; height: 80%; }
			#menuContainer div.small img { width: 10%; }
		</style>
	</head>
	<body onload="Game.webGLStart(1);">
		<div id="container">
			<div id="menuContainer" oncontextmenu="return false;">
				<!-- Main Menu -->
				<div gui-role="menu" gui-id="mainMenu" class="menu">
					<!--<h1>WebGL ZeroG</h1>-->
<pre>
 _____                 ___ 
/ _  / ___ _ __ ___   / _ \
\// / / _ \ '__/ _ \ / /_\/
 / //\  __/ | | (_) / /_\\ 
/____/\___|_|  \___/\____/  Alpha
</pre>
					<ul gui-role="links">
						<li><a gui-target="levelMenu">New Game</a></li>
						<li><a gui-target="optionsMenu">Options</a></li>
						<li><a gui-target="tutorialMenu">How to Play</a></li>
						<li><a gui-target="creditsMenu">Credits</a></li>
						<li><a gui-target="feedbackMenu">Feedback</a></li>
					</ul>
				</div>
				<!-- Tutorial Menu -->
				<div gui-role="menu" gui-id="tutorialMenu" class="menu">
					<h2>How to Play</h2>
					<div class="small">
						<p>ZeroG is a space shooter with slightly more realistic physics than your average!</p>
						<p>If you're moving you will carry on moving in that direction until you accelerate in the opposite! There is no top speed so if you're closing in on an object remember to leave enough time to decelerate or you'll just go straight past... or possibly collide.</p>
						<p>Talking of collisions, the damage recieved from them, both from bullets and other ships, is related to their relative velocities, so bear that in mind!</p>
						<p>WASD controls your acceleartion, Q and E roll your ship, right click turns your ship, and left click fires. Esc pauses the game.</p>
						<p>Have fun and leave feedback!</p>
					</div>
					<div>
						<input gui-role="navButton" gui-target="mainMenu" type="button" value="Cancel" />
					</div>
				</div>
				<!-- Options Menu -->
				<div gui-role="menu" gui-id="optionsMenu" class="menu">
					<h2>Options</h2>
					<form>
						<div>
							<label for="optionsResolution">Resolution</label>
							<input id="optionsResolution" type="range" class="range" min="0.1" max="1.0" step="0.1" value="1" />
							<span id="optionsResolutionOutput">1.0</span>
						</div>
						<div>
							<label for="optionsLighting">Lighting</label>
							<select id="optionsLighting">
								<option value="false">No Lighting</option>
								<option value="Vertex">Per Vertex</option>
								<option value="Pixel" selected>Per Pixel</option>
							</select>
						</div>
						<div>
							<label for="optionsSpecularLighting">Specular Lighting</label>
							<select id="optionsSpecularLighting">
								<option value="false" selected>Off</option>
								<option value="true">On</option>
							</select>
						</div>
						<div>
							<input gui-role="navButton" gui-target="mainMenu" type="button" value="Cancel" />
							<input gui-role="navButton applyOptions" gui-target="mainMenu" type="button" value="Okay" />
						</div>
					</form>
				</div>
				<!-- Level Menu -->
				<div gui-role="menu" gui-id="levelMenu" class="menu">
					<h2>Select Level</h2>
					<ul class="links">
						<!-- Add Game Start -->
						<li><a gui-role="navButton startGame" gui-target="pauseMenu" gui-level="1">Deep Space</a></li>
					</ul>
					<input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" />
				</div>
				<!-- Credits Menu -->
				<div gui-role="menu" gui-id="creditsMenu" class="menu">
					<h2>Credits</h2>
					<div class="small">
						<img src="textures/delph.png" alt="delph" />
						<p>Game design and programming by <a target="_blank" href="http://twitter.com/_delph/">delph</a></p>
						<p>Powered by Gremlins</p>
						<p>Thanks To:</p>
						<p><a  target="_blank" href="http://twitter.com/#!/gpjt">gpjt</a> &amp; <a target="_blank" href="http://twitter.com/Tojiro">Tojiro</a></p>
					</div>
					<div><input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" /></div>
				</div>
				<!-- Feedback Menu -->
				<div gui-role="menu" gui-id="feedbackMenu" class="menu">
					<h2>Feedback</h2>
					<p>Please leave feedback on <a target="_blank" href="http://delphic.me.uk/ZeroGWebGL.html">my website</a> or message me <a href="http://www.twitter.com/_delph/">@_delph</a> on twitter.</p>
					<div><input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" /></div>
				</div>
				<!-- Pause Menu -->
				<div gui-role="menu" gui-id="pauseMenu" class="menu">
					<h2>Paused</h2>
					<div>
						<div><input gui-role="resumeGame" type="button" value="Resume"/></div>
						<div><input gui-role="navButton menuResume" gui-target="mainMenu" id="btnPauseExit" type="button" value="Main Menu"/></div>
					</div>
				</div>
			</div>
			<div id="hudContainer" oncontextmenu="return false;">
				<!-- Temporary HUD - Replace with WebGL implementation -->
				<style>
					#hudContainer { display: none; z-index: 100; height: 0; width: 0;}
					#playerHUD { position: fixed; bottom: 10px; overflow: hidden; width: 100%; padding: 0 2.5%; z-index: 100; }
					#playerHUD .col { float: left; width: 25%; }
					#playerHUD .col label { font-size: 12px; line-height: 25px; color: #FFF; font-family: monospace; }
					#playerHUD .col .container { border: 1px solid #ACF; overflow: hidden; height: 25px; width: 80%; }
					#playerHUD .health, #playerHUD .shield, #playerHUD .fuel, #playerHUD .energy { float: left; height: 100%; }
					#playerHUD .health { background-color: #090; }
					#playerHUD .shield { background-color: #009; }
					#playerHUD .fuel { background-color: #AA0; }
					#playerHUD .energy { background-color: #D90; }
				</style>	
				<div id="playerHUD">
					<div class="col">
						<label>Health:</label>
						<div class="container">
							<div class="health"></div>
						</div>
					</div>
					<div class="col">
						<label>Shield:</label>
						<div class="container">
							<div class="shield"></div>
						</div>
					</div>
					<div class="col">
						<label>Fuel:</label>
						<div class="container">
							<div class="fuel"></div>
						</div>
					</div>
					<div class="col">
						<label>Energy:</label>
						<div class="container">
							<div class="energy"></div>
						</div>
					</div>
				</div>
			</div>
			<canvas id="gremlinCanvas" oncontextmenu="return false;"></canvas>
		</div>
	</body>
</html>