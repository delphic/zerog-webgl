<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<title>Gremlin Test Index</title>
		<!--<script type="text/javascript" src="libs/jquery-1.6.1.min.js"></script>-->
		<script type="text/javascript" src="libs/glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="libs/webgl-utils.js"></script>
		<!-- Shaders -->
		<script id="vertex-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			uniform vec4 uColor;
			uniform sampler2D uSampler;

			void main(void) {
				vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
				gl_FragColor = vec4(textureColor.rgb * uColor.rgb * vLightWeighting, textureColor.a); // TODO: think about how to use, uColor alpha and if we should
			}
		</script>
		<script id="vertex-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform bool uUseLighting;
			
			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			void main(void) {
				vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * mvPosition;
				vTextureCoord = aTextureCoord;
				
				if(!uUseLighting) {
					vLightWeighting = vec3(1.0, 1.0, 1.0);
				}else {
					vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
					
					// Point Lights
					// TODO: Investigate using just vertexposition instead of mvPosition and not transforming the normals
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - mvPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - mvPosition.xyz);
						float pointLightWeighting = max(dot(transformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						// Check if position in the cone
						float angleToMv = acos(dot((mvPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - mvPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightThi[i]);
						}
						else {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightTheta[i]);
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
					
					vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				}
			}
		</script>
		<script id="pixel-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			uniform vec4 uColor;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform float uMaterialShininess;
			
			uniform bool uUseLighting;
			uniform bool uUseSpecular;

			uniform sampler2D uSampler;


			void main(void) {
				vec3 lightWeighting;
				if (!uUseLighting) {
					lightWeighting = vec3(1.0, 1.0, 1.0);
				} else {
					// For Specular Lighting
					vec3 eyeDirection = normalize(-vPosition.xyz);
				
					// Point Lights
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - vPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - vPosition.xyz);
						float pointLightWeighting = max(dot(vTransformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						// Specular
						float specularLightWeighting = 0.0;
						if (uUseSpecular) {
							vec3 reflectionDirection = reflect(-pointLightDirection, vTransformedNormal);
							specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
						}
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting + uPointLightingColor[i] * specularLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						float specularLightWeighting = 0.0;
						// Check if position in the cone
						float angleToMv = acos(dot((vPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - vPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightThi[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						else {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightTheta[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting + uSpotLightColor[i] * specularLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(vTransformedNormal, uLightingDirection), 0.0);
					
					lightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				} 
				
				vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
				gl_FragColor = vec4(textureColor.rgb  * uColor.rgb * lightWeighting, textureColor.a);
			}
		</script>
		<script id="pixel-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			void main(void) {
				vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * vPosition;
				vTextureCoord = aTextureCoord;
				vTransformedNormal = normalize(uNMatrix * aVertexNormal);
			}
		</script>
		<!-- Gremlin Engine -->
		<script type="text/javascript" src="Gremlin.js"></script>
		<!-- Game Script -->
		<script type="text/javascript">
	var canvas;
	var fullScreen;
	var	resolutionX;
	var resolutionY;
    var lastTime = 0;
	
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
			
			// Animate Objects
			for(object in gameObjects)
			{
				gameObjects[object].animate(elapsed);
			}
			
			// Handle Input
			// TODO: Separate into function
			// TODO: game state variable... switch on this to control handling of input e.g. Menus
			// BUG: Keys get 'stuck down'
			var width = parseInt(canvas.style.width, 10);
			var height = parseInt(canvas.style.height, 10);
			var dyaw, dpitch, dx, dz;
			dyaw = 0.05 * elapsed * ((width*0.5)-xPos)/(0.5*width);
			dpitch = 0.05 * elapsed * ((height*0.5)-yPos)/(0.5*height);
			if (mouseDown) Gremlin.rotatePlayerCamera(dyaw, dpitch);
			
			if (currentlyPressedKeys[37] || currentlyPressedKeys[65]) {
				// Left cursor key or A
				// Strafe Left
				dx = -0.005 * elapsed;
			} 
			else if (currentlyPressedKeys[39] || currentlyPressedKeys[68]) {
				// Right cursor key or D
				// Strafe Right
				dx = 0.005  * elapsed;
			}
			else dx = 0;

			if (currentlyPressedKeys[38] || currentlyPressedKeys[87]) {
				// Up cursor key or W
				// Move Forward
				dz = -0.005  * elapsed;
			} else if (currentlyPressedKeys[40] || currentlyPressedKeys[83]) {
				// Down cursor key or S
				// Move Backward
				dz = 0.005  * elapsed;
			} 			
			else dz = 0;
			// TODO: Fix diagonal movement speed
			Gremlin.movePlayerCamera(dx,0,dz);
        }
        lastTime = timeNow;
    }

    function tick() {
        if(controller.isRunning()) { requestAnimFrame(tick); }

		// Render Scene
		// TODO: Make separate function
        Gremlin.prepareScene();
		for(object in gameObjects)
		{
			if(gameObjects[object].visible) {
				Gremlin.renderObject(gameObjects[object]);
			}
		}
		
		// Animate Scene
        animate();
    }

	// Game Objects Array
	var gameObjects = [];
	// Lights should possibly be a game objects, else we need to add an animate function
	var gamePointLights = [];
	var gameSpotLights = [];
	
	// Game Object Obj
	function gameObject(x,y,z) {
		this.x = x;
		this.y = y;
		this.z = z;
		
		this.rotation = mat4.create();
		mat4.identity(this.rotation);
		
		this.buffers = [];
		this.scale = 1;
		// TODO: Proper Material System?
		// TODO: Make into array for multiple texture IDs
		this.texture;
		this.color = [1.0,1.0,1.0,1.0];
		this.setColor = setColor;
		this.shininess = 10;
		this.setShininess = setShininess;
		
		this.move = move;
		this.setPosition = setPosition;
		this.rotate = rotate;
		this.setRotation = setRotation;
		this.animate = defaultAnimation;
		this.assignBuffer = assignBuffer;

		// Render Flags
		// Consider: Moving to Renderer
		this.visible = true;
		this.wireframe = false;
		this.useIndices = false;
		this.useTextures = false;
		
		function setPosition(x,y,z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}
		function move(dx, dy, dz) {
			this.x += dx;
			this.y += dy;
			this.z += dz;
		}
		function rotate(amount, X, Y, Z) {
			mat4.rotate(this.rotation, Gremlin.degToRad(amount), [X, Y, Z]);
		}
		function setRotation(yaw, pitch, roll) {
			mat4.identity(this.rotation);
			// TODO: Check order of rotations
			mat4.rotate(this.rotation, Gremlin.degToRad(yaw), [0,1,0]);
			mat4.rotate(this.rotation, Gremlin.degToRad(pitch), [1,0,0]);
			mat4.rotate(this.rotation, Gremlin.degToRad(roll), [0,0,0]);
		}
		function setColor(r,g,b,a) { this.color = [r,g,b,a]; }
		function setShininess(val) { this.shiniess = val; }
		function defaultAnimation() { /* Blank */ }
		function assignBuffer(name, buffer) {
			this.buffers[name] = buffer;
		}
	}
	
	// Game Init
	function gameInit() {
		// Lighting
		Gremlin.setLightEnvironment(0.4,0.4,0.4,0.4,0.4,0.4,-1.0,0.0,0.0);
		Gremlin.setLighting(true);
		
		Gremlin.addPointLight(0,0,-6.0,0.0,2.0,0);
		Gremlin.addPointLight(0,0,-5.5,6.0,2.0,0);

		Gremlin.addSpotLight(0,0,0,-0.15,0,-1,1,0,1,5,8,2.0);
		Gremlin.addSpotLight(0,0,-1,0,0,-1,5,1,1,20,45,2.0);
		
		// Game Objects
		var cube = new gameObject(-1.5,0,-8.0);
		var sphere = new gameObject(1.5, 0, -8.0);
		var teapot = new gameObject(0,0,-5);
		
		Gremlin.createPrimitive(cube, "cube", false, true, 1.0, 0, 0);
		Gremlin.createPrimitive(sphere, "sphere", false, true, 1.5, 30, 30);
		Gremlin.loadModel(teapot, "Teapot.json", 0.1);
		
		gameObjects["cube"] = cube;
		gameObjects["sphere"] = sphere;
		gameObjects["teapot"] = teapot;
		
		// TODO: Move to texture and handle event to Texture List in Engine, store index in gameobject
		// TODO: Move Texture Filtering to engine globals
		gameObjects.cube.texture = Gremlin.createTexture("textures/crate.gif");
		gameObjects.cube.texture.image.onload = function() { Gremlin.handleLoadedTexture(gameObjects.cube.texture, 3); } 
		
		gameObjects.sphere.texture = Gremlin.createTexture("textures/earth.jpg");
		gameObjects.sphere.texture.image.onload = function() { Gremlin.handleLoadedTexture(gameObjects.sphere.texture, 3); }
		
		gameObjects.teapot.texture = Gremlin.createTexture("textures/metal.jpg");
		gameObjects.teapot.texture.image.onload = function() { Gremlin.handleLoadedTexture(gameObjects.teapot.texture, 3); }
		
		//gameObjects.cube.animate = function(elapsed) { this.rotate( ( (75 * elapsed) / 1000.0), 1, 1, 1); };
		//gameObjects.sphere.animate = function(elapsed) { this.rotate( ( (-50 * elapsed) / 1000.0), 0, 1, 0); };
		gameObjects.teapot.animate = function(elapsed) { this.rotate( ( (30 * elapsed) / 1000.0), 0,1,0); };
		
		gameObjects.teapot.setShininess(100);
	}
	
	// WebGL Start
	
    function webGLStart(fullScreen, resX, resY) {
		canvas = document.getElementById("gremlinCanvas");
		isFullScreen = fullScreen;
		resolutionX = resX;
		resolutionY = resY;
		setCanvasSize();
		
		// Initialise
		Gremlin.init();
		gameInit();
		
		// Start Game Loop
        tick();
		
		document.onkeydown = handleKeyDown;
		document.onkeyup = handleKeyUp;
		canvas.onmousemove = handleMouseMove;
		canvas.onmousedown = handleMouseDown;
		canvas.onmouseup = handleMouseUp;
    }
	
	// Input Handling
	// TODO: Should not effect the canvas if mousemoves outside of the canvas.
	var xPos, yPos;
	var currentlyPressedKeys = {};
	var mouseDown = false;

	function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;
	}
	function handleKeyUp(event) {
		currentlyPressedKeys[event.keyCode] = false;
	}
	function handleMouseMove(event) {
		// TODO: Investigate the difference between clientX and pageX
		xPos = event.pageX - this.offsetLeft;
		yPos = event.pageY - this.offsetTop;
	}
	function handleMouseDown(event) {
		// TODO: Add vars for middle and right
		// 0 = left, 1 = middle, 2 = right
		if (!event.button) { mouseDown = true; }
		return false;
	}
	function handleMouseUp(event) {
		if (!event.button) { mouseDown = false; }
	}
	
	// Controller Bar
	
	function _controller() {
		// TODO: Move pause functions to Engine.
		var running = true;
		var usingWireFrames = false;
		var windowPaused = false;
		
		function handlePause() { 
			if(running) { 
				_pause();
				// TODO: save the control objects
				var btn = document.getElementById("btnPause").value = "Start"; 
			} 
			else { 
				_unpause();
				var btn = document.getElementById("btnPause").value = "Stop"; 
			}
		}
		
		function handleWindowBlur() {
			if(running) {
				windowPaused = true;
				_pause();
			}
		}
		
		function handleWindowFocus() {
			if(windowPaused) {
				windowPaused = false;
				_unpause();
			}
		}
		function isRunning() { return running; }
		function toggleWireFrames() { if (usingWireFrames) { usingWireFrames = false; } else { usingWireFrames = true; } }
		function useWireFrames() { return usingWireFrames; }
		function _pause() { running = false; }
		// TODO: when the game timer moves to an object adjust this		
		function _unpause() { running = true; lastTime = new Date().getTime(); requestAnimFrame(tick); }
		
		return { 
			isRunning: isRunning, 
			handlePause: handlePause, 
			useWireFrames: useWireFrames,
			toggleWireFrames: toggleWireFrames, 
			handleWindowBlur: handleWindowBlur, 
			handleWindowFocus: handleWindowFocus 
		};
	}
	var controller = _controller();
	
	function setCanvasSize() {
		if (resolutionX) {
			canvas.width = resolutionX;
			canvas.height = resolutionY;
		}
		else {
			canvas.width = document.width;
			canvas.height = window.innerHeight;
		}
		if (isFullScreen) {
			canvas.style.width = document.width+"px";
		canvas.style.height = window.innerHeight+"px";
		}
		else {
			canvas.style.width = resolutionX+"px";
			canvas.style.height = resolutionY+"px";
		}
	}
	
	window.onblur = function() { controller.handleWindowBlur(); }
	window.onfocus = function() { controller.handleWindowFocus(); }
	window.onresize = function() { setCanvasSize(); Gremlin.resize(); }
	
		</script>
		<style>
			html, body { margin: 0; padding: 0; overflow: hidden; font-family: monospace; }
			input { margin-top: 10px; font-size: 16px; margin: 5px 10px; padding: 3px; background: #000; color: #EEE; border: 1px solid #222; }
			canvas { display: block; margin: 0 auto; /*cursor: url('data:image/gif;base64,R0lGODlhAQABAPAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto; */ cursor: crosshair; }
			#controls { width: 100%; background-color: #666; cursor: default; height: 40px; }
		</style>
	</head>
	<body onload="webGLStart(true);">
		<div id="container">
			<!--<div id="controls">
				<input id="btnPause" type="button" onclick="controller.handlePause();" value="Stop" />
				<input id="btnWireFrames" type="button" onclick="controller.toggleWireFrames();" value="Toggle Wireframes" />
			</div>-->
			<!-- TODO: add inital screen telling you controls -->
			<!-- TODO: Remove Inline Styles -->
			<canvas id="gremlinCanvas"></canvas>
		</div>
	</body>
</html>