<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<title>Gremlin Test Index</title>
		<script type="text/javascript" src="libs/jquery-1.6.1.min.js"></script>
		<script type="text/javascript" src="libs/glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="libs/webgl-utils.js"></script>
		<!-- Shaders -->
		<script id="vertex-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			uniform vec4 uColor;
			uniform bool uUseTextures;
			uniform sampler2D uSampler;

			void main(void) {
				if(uUseTextures) {
					vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
					gl_FragColor = vec4(textureColor.rgb * uColor.rgb * vLightWeighting, textureColor.a); // TODO: think about how to use, uColor alpha and if we should
				}
				else {
					gl_FragColor = vec4(uColor.rgb * vLightWeighting, uColor.a);
				}
			}
		</script>
		<script id="vertex-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform bool uUseLighting;
			
			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			void main(void) {
				vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * mvPosition;
				vTextureCoord = aTextureCoord;
				
				if(!uUseLighting) {
					vLightWeighting = vec3(1.0, 1.0, 1.0);
				}else {
					vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
					
					// Point Lights
					// TODO: Investigate using just vertexposition instead of mvPosition and not transforming the normals
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - mvPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - mvPosition.xyz);
						float pointLightWeighting = max(dot(transformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						// Check if position in the cone
						float angleToMv = acos(dot((mvPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - mvPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightThi[i]);
						}
						else {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightTheta[i]);
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
					
					vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				}
			}
		</script>
		<script id="pixel-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			uniform vec4 uColor;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform float uMaterialShininess;
			
			uniform bool uUseLighting;
			uniform bool uUseSpecular;
			
			uniform bool uUseTextures;

			uniform sampler2D uSampler;


			void main(void) {
				vec3 lightWeighting;
				if (!uUseLighting) {
					lightWeighting = vec3(1.0, 1.0, 1.0);
				} else {
					// For Specular Lighting
					vec3 eyeDirection = normalize(-vPosition.xyz);
				
					// Point Lights
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - vPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - vPosition.xyz);
						float pointLightWeighting = max(dot(vTransformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						// Specular
						float specularLightWeighting = 0.0;
						if (uUseSpecular) {
							vec3 reflectionDirection = reflect(-pointLightDirection, vTransformedNormal);
							specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
						}
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting + uPointLightingColor[i] * specularLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						float specularLightWeighting = 0.0;
						// Check if position in the cone
						float angleToMv = acos(dot((vPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - vPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightThi[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						else {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightTheta[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting + uSpotLightColor[i] * specularLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(vTransformedNormal, uLightingDirection), 0.0);
					
					lightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				} 
				if(uUseTextures) {
					vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
					gl_FragColor = vec4(textureColor.rgb  * uColor.rgb * lightWeighting, textureColor.a);
				}
				else {
					gl_FragColor = vec4(uColor.rgb * lightWeighting, uColor.a);
				}
			}
		</script>
		<script id="pixel-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			void main(void) {
				vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * vPosition;
				vTextureCoord = aTextureCoord;
				vTransformedNormal = normalize(uNMatrix * aVertexNormal);
			}
		</script>
		<!-- Gremlin Engine -->
		<script type="text/javascript" src="Gremlin.js"></script>
		<!-- GUI : Note JQuery Depedency -->
		<script src="GUI.js"></script>
		<!-- Game Script -->
		<script type="text/javascript">
function _Game() {
	// TODO: Change naming to public / private functions...
	var canvas;
	var	resolutionScale;
	var lastTime = 0;
	var gameState = "InMenu"; // TODO: This should loading for initial load.
	
	var loadingTargetState;
	var assetsLoading = 0; // for quick and dirty loading system
	function decreaseAssetsLoading() { // to be removed / moved to proper loading system
		assetsLoading -= 1;
	}

	// Game State Functions
	function updateGameState(val) {
		gameState = val;
	}
	
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
			
			// Animate Objects
			for(object in gameObjects)
			{
				gameObjects[object].animate(elapsed);
			}
			
			// Handle Game Input
			// TODO: game state variable... switch on this to control handling of input e.g. Menus
			// BUG: Keys get 'stuck down'
			if(gameState == "InGame") {
				var width = parseInt(canvas.style.width, 10);
				var height = parseInt(canvas.style.height, 10);
				var mousePos, lmbDown, rmbDown;
				mousePos = GremlinInput.getMousePos();
				lmbDown = GremlinInput.mouseDown(0);
				rmbDown = GremlinInput.mouseDown(2);
				
				var dyaw, dpitch, droll, dx, dz;
				dyaw = 0.05 * elapsed * ((width*0.5)-mousePos[0])/(0.5*width);
				dpitch = 0.05 * elapsed * ((height*0.5)-mousePos[1])/(0.5*height);
				droll = 0;
				if (GremlinInput.keyDown("q")) { 
					droll += 0.1 * elapsed; 
				}
				if (GremlinInput.keyDown("e")) { droll -= 0.1 * elapsed; }
				if (rmbDown) Gremlin.rotatePlayerCamera(dyaw, dpitch, droll);
				else if (GremlinInput.keyDown("q") || GremlinInput.keyDown("e")) { Gremlin.rotatePlayerCamera(0, 0, droll); }

				// Pew Pew
				if(lmbDown) {
					if (player.firingTimer >= 300) {
						var pos = [0,0,0];
						Gremlin.playerCameraPos(pos); // Note setting equal to player.position cause updating the camera as well as the projectiles! TODO: put player in an object / namespace rather than store as an array to remove this temptation!
						var aimtAt = [0,0,0];
						aimAt = Gremlin.pickPosition(mousePos[0], mousePos[1], 500); // 500 should be replaced by distance to target
						var v = [0,0,0]; 
						vec3.subtract(aimAt, pos, v);
						v[0]/=1000;
						v[1]/=1000;
						v[2]/=1000;
						//Gremlin.playerCameraReverseRotation(v);
						
						v[0] += player.velocity[0];
						v[1] += player.velocity[1];
						v[2] += player.velocity[2];
						
						var newproj = new projectile(pos, v, 10, 30000, true);

						projectiles.push(newproj);
						player.firingTimer = 0;
					}
					else {
						player.firingTimer += elapsed;
					}
				}
				
				dx = 0;
				dz = 0;
				if (GremlinInput.keyDown("Left") || GremlinInput.keyDown("a")) {
					// Strafe Left
					dx -= 0.005 * elapsed;
				} 
				else if (GremlinInput.keyDown("Right") || GremlinInput.keyDown("d")) {
					// Strafe Right
					dx += 0.005  * elapsed;
				}

				if (GremlinInput.keyDown("Up") || GremlinInput.keyDown("w")) {
					// Move Forward
					dz -= 0.005  * elapsed;
				} 
				else if (GremlinInput.keyDown("Down") || GremlinInput.keyDown("s")) {
					// Move Backward
					dz += 0.005  * elapsed;
				}
				
				if(dx && dz) { // Clamp Diagonal Speed
					dx /= 1.41421;
					dz /= 1.41421;
				}
				// TODO: Add regen-ing to fuel to stop people accelerating to stupid speeds easily
				// Could have higher fuel use to begin with and particularly low use if low on fuel

				var dvelocity = [];
				dvelocity[0] = (0.01*dx/player.mass);
				dvelocity[1] = 0;
				dvelocity[2] = (0.01*dz/player.mass);
				Gremlin.playerCameraReverseRotation(dvelocity);
				
				player.velocity[0]+=dvelocity[0];
				player.velocity[1]+=dvelocity[1];
				player.velocity[2]+=dvelocity[2];
				
				Gremlin.setPlayerCamera(player.position[0]+player.velocity[0],player.position[1]+player.velocity[1],player.position[2]+player.velocity[2]); 
				Gremlin.playerCameraPos(player.position);
				
				if (GremlinInput.keyDown("Esc")) {
					updateGameState("InMenu");
					pause();
					GremlinGUI.pause();
				}
			}
			
			// Update Motes
			updateMotes(player.position, player.velocity);
			
			// Update Projectiles
			for(var i = 0; i < projectiles.length; i++) {
				// Update Lifetime
				projectiles[i].lifetime -= elapsed;
				// Despawn if lifetime has expired
				if (projectiles[i].lifetime < 0) {
					projectiles.splice(i,1);
				}
				else {
					// Update Position
					projectiles[i].updatePosition();
				}
			}
			
        }
        lastTime = timeNow;
    }

    function tick() {
        if(controller.isRunning()) { requestAnimFrame(tick); }
		
		if(gameState == "Loading") {
			// Wait for all assets to load
			if(assetsLoading) return;
			else gameState == loadingTargetState;
		}
		
		// Render Scene
		// TODO: Make separate function
        Gremlin.prepareScene();
		for(object in gameObjects)
		{
			if(gameObjects[object].visible) {
				Gremlin.renderObject(gameObjects[object]);
			}
		}
		for(var i = 0; i < maxMotes; i++)
		{
			// Note: Not an efficient method of rendering particles...
			// We can get away with this because it's only ~100 objects
			Gremlin.renderObject(dustMotes[i]);
		}
		for(var n = 0; n < projectiles.length; n++)
		{
			var position = [0,0,0];
			position = projectiles[n].getPosition();
			projectileObject.setPosition(position[0], position[1], position[2]);
			Gremlin.renderObject(projectileObject);
		}
		
		// Animate Scene
        animate();
    }

	// Game Objects Array
	var gameObjects = [];
	// Lights should possibly be a game objects, else we need to add an animate function
	var gamePointLights = [];
	var gameSpotLights = [];
	
	// Game Object Obj
	function gameObject(x,y,z) {
		this.x = x;
		this.y = y;
		this.z = z;
		
		this.rotation = mat4.create();
		mat4.identity(this.rotation);
		
		this.buffers = [];
		this.scale = 1;
		// TODO: Proper Material System?
		// TODO: Make into array for multiple texture IDs
		this.texture;
		this.color = [1.0,1.0,1.0,1.0];
		this.setColor = setColor;
		this.useLighting = true;
		this.setUseLighting = setUseLighting;
		this.shininess = 0;
		this.setShininess = setShininess;
		
		this.isSkyBox = false;
		this.setIsSkyBox = setIsSkyBox;
		
		this.move = move;
		this.setPosition = setPosition;
		this.rotate = rotate;
		this.setRotation = setRotation;
		this.animate = defaultAnimation;
		this.assignBuffer = assignBuffer;

		// Render Flags
		// Consider: Moving to Renderer
		this.visible = true;
		this.wireframe = false;
		this.points = false; // TODO: Combine this and wireframe into a render type (triangles / lines / points etc)
		this.useIndices = false;
		this.useTextures = false;
		
		function setPosition(x,y,z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}
		function move(dx, dy, dz) {
			this.x += dx;
			this.y += dy;
			this.z += dz;
		}
		function rotate(amount, X, Y, Z) {
			mat4.rotate(this.rotation, Gremlin.degToRad(amount), [X, Y, Z]);
		}
		function setRotation(yaw, pitch, roll) {
			mat4.identity(this.rotation);
			// TODO: Check order of rotations
			mat4.rotate(this.rotation, Gremlin.degToRad(yaw), [0,1,0]);
			mat4.rotate(this.rotation, Gremlin.degToRad(pitch), [1,0,0]);
			mat4.rotate(this.rotation, Gremlin.degToRad(roll), [0,0,0]);
		}
		function setColor(r,g,b,a) { this.color = [r,g,b,a]; }
		function setUseLighting(val) { this.useLighting = val; }
		function setShininess(val) { this.shininess = val; }
		
		function setIsSkyBox(val) { this.isSkyBox = val; if(this.isSkyBox) this.useLighting = false; } 
		
		function defaultAnimation() { /* Blank */ }
		function assignBuffer(name, buffer) {
			this.buffers[name] = buffer;
		}
	}
	
	// Creation Objection
	function createObjectPrimitive(position, primType, textureName, size, latBands, longBands, animation, shininess, isSkyBox) {
		var object = new gameObject(position[0], position[1], position[2]);
		var textured;
		if (textureName) { 
			textured = true;
		}
		else {
			textured = false;
		}
		switch(primType) {
		case "pyramid":
			Gremlin.createPyramid(object, textured, size);
			break;
		case "cube": 
			Gremlin.createCube(object, textured, size);
			break;
		case "sphere":
			Gremlin.createSphere(object, textured, size, latBands, longBands);
			break;
		case "ray":
			Gremlin.createRay(object, size);
			break;
		case "point":
			Gremlin.createPoint(object);
			break;
		default:
			alert("Invalid Prim Type: "+primType+"");
			return;
		}
		// TODO: Move to separate texture list and jsut assign appropriate index
		if(textured) {
			assetsLoading += 1;
			object.texture = Gremlin.createTexture(textureName);
			object.texture.image.onload = function() { Gremlin.handleLoadedTexture(object.texture, 3); assetsLoading -= 1; } // TODO: Replace 3 with FilterType
		}
		if(shininess) {
			object.setShininess(shininess);
		}
		if(isSkyBox) {
			object.setIsSkyBox(true);
		}
		if(animation) {
			object.animate = animation;
		}
		gameObjects.push(object);
	}

	function createObjectModel(position, modelName, textureName, scale, animation, shininess) {
		var object = new gameObject(position[0], position[1], position[2]);
		var textured;
		if (textureName) { 
			textured = true;
		}
		else {
			textured = false;
		}
		assetsLoading += 1;
		Gremlin.loadModel(object, modelName, scale, decreaseAssetsLoading);
		// TODO: Move to separate texture list and jsut assign appropriate index
		if(textured) {
			assetsLoading += 1;
			object.texture = Gremlin.createTexture(textureName);
			object.texture.image.onload = function() { Gremlin.handleLoadedTexture(object.texture, 3); assetsLoading -= 1; } // TODO: Replace 3 with FilterType
		}
		if(shininess) {
			object.setShininess(shininess);
		}
		if(animation) {
			object.animate = animation;
		}
		gameObjects.push(object);
	}
	// Game Init
	function gameInit() {
		gameState = "Loading";
		assetsLoading = 0;
		loadingTargetState = "InGame";
		loadLevel("level1.js");
		createMotes();
		// Create Projectiles
		Gremlin.createPyramid(projectileObject, false, 0.01); // TODO: Tumbling Tetrahedron would be better
	}
	

	// Player / Ships
	var player = [];
	player.position = [0,0,0];
	player.velocity = [0,0,0];
	player.mass = 1;
	player.firingTimer = 1000;

	// Basic Projectile System
	var projectiles = [];
	var projectileObject = new gameObject(0,0,0);
	projectileObject.rotate(90, 1, 0, 0)
	projectileObject.setColor(5.0,0,0,1);
	projectileObject.setUseLighting(false);
		
	function projectile(position, velocity, dmg, lifetime, friendly) {
		this.position = position;
		this.velocity = velocity;
		this.dmg = dmg;
		this.lifetime = lifetime;
		this.friendly = friendly;
		
		this.getPosition = getPosition;
		this.updatePosition = updatePosition;
		
		function getPosition() {
			return this.position;
		}
		function updatePosition() {
			this.position[0] += this.velocity[0];
			this.position[1] += this.velocity[1];
			this.position[2] += this.velocity[2];
		}
	}
	
	// Dust Motes
	// TODO: namespace
	var dustMotes = [];
	var maxMotes, randomFactor, rootThree;
	rootThree = 1.73205; // Approximately
	randomFactor = 10; // To Be Adjusted
	maxMotes = 100; // To Be Adjusted
	
	function createMotes() {
		for(var i = 0; i < maxMotes; i++) {
			var obj = new gameObject(2*randomFactor*(Math.random()-0.5), 2*randomFactor*(Math.random()-0.5), 2*randomFactor*(Math.random()-0.5));
			Gremlin.createPoint(obj);
			obj.points = true;
			obj.useLighting = false; // If we want the motes to be lit properly we'll have to figure out the normal to a point!
			obj.setColor(0.8,0.8,0.8,1);
			dustMotes.push(obj); 
		}
	}
 
	function updateMotes(pos, vel) {
		if (vec3.length(vel)) {
			for(var i = 0; i < maxMotes; i++){
				var boundingR;
				var posDiff = vec3.create();
				boundingR = vec3.length(vel) + rootThree*randomFactor;
				vec3.subtract(pos,[dustMotes[i].x, dustMotes[i].y, dustMotes[i].z], posDiff); 
				if (vec3.length(posDiff) >  boundingR) {
					// Respawn on opposite site of sphere 
					dustMotes[i].setPosition(
						pos[0] + 0.99*posDiff[0],
						pos[1] + 0.99*posDiff[1],
						pos[2] + 0.99*posDiff[2]
					);
				}
			}
		}
	}
	
	// WebGL Start
	
    function webGLStart(resScale) {
		canvas = document.getElementById("gremlinCanvas");
		resolutionScale = resScale;
		setCanvasSize();
		
		// Initialise
		Gremlin.init();
		gameInit();
		
		// Start Game Loop
        tick();
		
    }
	
	// Controller Bar
	
	function _controller() {
		var running = true;
		var windowPaused = false;
		
		function handlePause() { 
			if(running) { 
				_pause();
			} 
			else { 
				_unpause();
			}
		}
		
		function handleUnpause() {
			if(!running) {
				_unpause();
			}
		}
		
		function handleWindowBlur() {
			if(running) {
				windowPaused = true;
				_pause();
			}
		}
		
		function handleWindowFocus() {
			if(windowPaused) {
				windowPaused = false;
				_unpause();
			}
		}
		function isRunning() { return running; }
		function _pause() { running = false; }
		// TODO: when the game timer moves to an object adjust this		
		function _unpause() { running = true; lastTime = new Date().getTime(); requestAnimFrame(tick); }
		
		return { 
			isRunning: isRunning, 
			handlePause: handlePause, 
			handleUnpause: handleUnpause,
			handleWindowBlur: handleWindowBlur, 
			handleWindowFocus: handleWindowFocus 
		};
	}
	var controller = _controller();
	
	function pause() {
		controller.handlePause();
	}
	function unpause() {
		controller.handleUnpause();
	}
	
	function setCanvasSize() {
		if (resolutionScale) {
			canvas.width = resolutionScale*document.width;
			canvas.height = resolutionScale*window.innerHeight;
		}
		else {
			canvas.width = document.width;
			canvas.height = window.innerHeight;
		}
		canvas.style.width = document.width+"px";
		canvas.style.height = window.innerHeight+"px";
	}
	
	GremlinEventHandler.bindEvent("onblur", controller.handleWindowBlur);
	GremlinEventHandler.bindEvent("onfocus", controller.handleWindowFocus);
	GremlinEventHandler.bindEvent("onresize", setCanvasSize);
	GremlinEventHandler.bindEvent("onresize", Gremlin.resize);
	
	function loadLevel(fileName) {
		var fileref=document.createElement('script');
		fileref.setAttribute("type","text/javascript");
		fileref.setAttribute("src", fileName);
		if (typeof fileref!="undefined") document.getElementsByTagName("head")[0].appendChild(fileref);
	}
	// TODO: Add check for already loaded
	
	return {
		createObjectPrimitive: 		createObjectPrimitive,
		createObjectModel: 			createObjectModel,
		decreaseAssetsLoading:  	decreaseAssetsLoading, // Remove / move to loading system
		updateGameState: 			updateGameState,
		pause:						pause,
		unpause:					unpause,
		webGLStart: 				webGLStart
	}
}
var Game = _Game();
		</script>
		<style>
			html, body { margin: 0; padding: 0; overflow: hidden; font-family: monospace; }
			canvas { display: block; margin: 0 auto; /*cursor: url('data:image/gif;base64,R0lGODlhAQABAPAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto; */ cursor: crosshair; }
			/* CSS Styles*/
			#menuContainer { color: #FFF; margin: 0 auto; position: absolute; padding: 0 2.5%; z-index: 100; }
			#menuContainer ul { list-style: none; padding: 0; }
			#menuContainer ul li { margin: 0.5em 0;}
			#menuContainer ul li a { cursor: pointer; color: #FFF; }
			#menuContainer a { color: #ACF; }
			#menuContainer select, #menuContainer input { background-color: #000; color: #FFF; border: none; font-size: 0.8em; font-family: monospace; }
			#menuContainer input[type=button] { margin: 0.5em 0; color: #ACF; cursor: pointer; }
			#menuContainer div.small { font-size: 0.5em; overflow-y: scroll; height: 80%; }
			#menuContainer div.small img { width: 10%; }
		</style>
	</head>
	<body onload="Game.webGLStart(1);">
		<div id="container">
			<div id="menuContainer">
				<!-- Main Menu -->
				<div gui-role="menu" gui-id="mainMenu">
					<!--<h1>WebGL ZeroG</h1>-->
<pre>
 _____                 ___ 
/ _  / ___ _ __ ___   / _ \
\// / / _ \ '__/ _ \ / /_\/
 / //\  __/ | | (_) / /_\\ 
/____/\___|_|  \___/\____/ 
</pre>
					<ul gui-role="links">
						<li><a gui-target="levelMenu">New Game</a></li>
						<li><a gui-target="optionsMenu">Options</a></li>
						<li><a gui-target="creditsMenu">Credits</a></li>
					</ul>
				</div>
				<!-- Options Menu -->
				<div gui-role="menu" gui-id="optionsMenu">
					<h2>Options</h2>
					<form>
						<div>
							<label for="optionsResolution">Resolution</label>
							<input id="optionsResolution" type="range" min="0.1" max="1.0" step="0.1" value="1" />
							<span id="optionsResolutionOutput">1.0</span>
						</div>
						<div>
							<label for="optionsLighting">Lighting</label>
							<select id="optionsLighting">
								<option value="false">No Lighting</option>
								<option value="Vertex">Per Vertex</option>
								<option value="Pixel" selected>Per Pixel</option>
							</select>
						</div>
						<div>
							<label for="optionsSpecularLighting">Specular Lighting</label>
							<select id="optionsSpecularLighting">
								<option value="false" selected>Off</option>
								<option value="true">On</option>
							</select>
						</div>
						<div>
							<input gui-role="navButton" gui-target="mainMenu" type="button" value="Cancel" />
							<input gui-role="navButton applyOptions" gui-target="mainMenu" type="button" value="Okay" />
						</div>
					</form>
				</div>
				<!-- Level Menu -->
				<div gui-role="menu" gui-id="levelMenu">
					<h2>Select Level</h2>
					<ul class="links">
						<!-- Add Game Start -->
						<li><a gui-role="navButton startGame" gui-target="pauseMenu" gui-level="1">Level 1</a></li>
					</ul>
					<input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" />
				</div>
				<!-- Credits Menu -->
				<div gui-role="menu" gui-id="creditsMenu">
					<h2>Credits</h2>
					<div class="small">
						<img src="textures/delph.png" alt="delph" />
						<p>Game design and programming by <a target="_blank" href="http://twitter.com/_delph/">delph</a></p>
						<p>Powered by Gremlins</p>
						<p>Thanks To:</p>
						<p><a  target="_blank" href="http://twitter.com/#!/gpjt">gpjt</a> &amp; <a target="_blank" href="http://twitter.com/Tojiro">Tojiro</a></p>
					</div>
					<div><input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" /></div>
				</div>
				<!-- Pause Menu -->
				<div gui-role="menu" gui-id="pauseMenu">
					<h2>Paused</h2>
					<div>
						<div><input gui-role="resumeGame" type="button" value="Resume"/></div>
						<div><input gui-role="navButton" gui-target="mainMenu" id="btnPauseExit" type="button" value="Main Menu"/></div>
					</div>
				</div>
			</div>
			<canvas id="gremlinCanvas" oncontextmenu="return false;"></canvas>
		</div>
	</body>
</html>