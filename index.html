<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<title>ZeroG Alpha - Cube Combat Evolved</title>
		<script type="text/javascript" src="libs/jquery-1.6.1.min.js"></script>
		<script type="text/javascript" src="libs/glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="libs/webgl-utils.js"></script>
		<!-- Shaders -->
		<script id="vertex-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			uniform vec4 uColor;
			uniform bool uUseTextures;
			uniform sampler2D uSampler;

			void main(void) {
				if(uUseTextures) {
					vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
					gl_FragColor = vec4(textureColor.rgb * uColor.rgb * vLightWeighting, textureColor.a); // TODO: think about how to use, uColor alpha and if we should
				}
				else {
					gl_FragColor = vec4(uColor.rgb * vLightWeighting, uColor.a);
				}
			}
		</script>
		<script id="vertex-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform bool uUseLighting;
			
			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			
			void main(void) {
				vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * mvPosition;
				vTextureCoord = aTextureCoord;
				
				if(!uUseLighting) {
					vLightWeighting = vec3(1.0, 1.0, 1.0);
				}else {
					vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
					
					// Point Lights
					// TODO: Investigate using just vertexposition instead of mvPosition and not transforming the normals
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - mvPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - mvPosition.xyz);
						float pointLightWeighting = max(dot(transformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						// Check if position in the cone
						float angleToMv = acos(dot((mvPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - mvPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightThi[i]);
						}
						else {
							spotLightWeighting = max(dot(transformedNormal, normalize(uSpotLightLocation[i] - mvPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - mvPosition.xyz) * uSpotLightTheta[i]);
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
					
					vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				}
			}
		</script>
		<script id="pixel-shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			uniform vec4 uColor;
			
			// Lighting
			uniform vec3 uAmbientColor;

			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColor;
			
			// Max Point Lights: 8
			uniform int uPointLightNumber;
			uniform vec3 uPointLightingLocation[8];
			uniform vec3 uPointLightingColor[8];
			
			// Spot Lights
			uniform int uSpotLightNumber;
			uniform vec3 uSpotLightLocation[8];
			uniform vec3 uSpotLightDirection[8];
			uniform vec3 uSpotLightColor[8];
			uniform float uSpotLightTheta[8];
			uniform float uSpotLightThi[8];
			uniform float uSpotLightFalloff[8];

			uniform float uMaterialShininess;
			
			uniform bool uUseLighting;
			uniform bool uUseSpecular;
			
			uniform bool uUseTextures;

			uniform sampler2D uSampler;


			void main(void) {
				vec3 lightWeighting;
				if (!uUseLighting) {
					lightWeighting = vec3(1.0, 1.0, 1.0);
				} else {
					// For Specular Lighting
					vec3 eyeDirection = normalize(-vPosition.xyz);
				
					// Point Lights
					vec3 pointLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uPointLightNumber) { break; }
						float pointLightDistance = length(uPointLightingLocation[i] - vPosition.xyz);
						vec3 pointLightDirection = normalize(uPointLightingLocation[i] - vPosition.xyz);
						float pointLightWeighting = max(dot(vTransformedNormal, pointLightDirection), 0.0) / (pointLightDistance*pointLightDistance);
						// Specular
						float specularLightWeighting = 0.0;
						if (uUseSpecular) {
							vec3 reflectionDirection = reflect(-pointLightDirection, vTransformedNormal);
							specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
						}
						pointLightComponent += uPointLightingColor[i] * pointLightWeighting + uPointLightingColor[i] * specularLightWeighting;
					}
					
					// Spot Lights
					vec3 spotLightComponent;
					for(int i = 0; i < 8; i++) {
						if (i >= uSpotLightNumber) { break; }
						float spotLightWeighting;
						float specularLightWeighting = 0.0;
						// Check if position in the cone
						float angleToMv = acos(dot((vPosition.xyz - uSpotLightLocation[i]), uSpotLightDirection[i])/(length(uSpotLightDirection[i])*length(uSpotLightLocation[i] - vPosition.xyz)));
						if (angleToMv > 0.5*uSpotLightThi[i]) { spotLightWeighting = 0.0; }
						else if (angleToMv > 0.5*uSpotLightTheta[i] && angleToMv < 0.5*uSpotLightThi[i]) {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (uSpotLightFalloff[i] * length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightThi[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						else {
							spotLightWeighting = max(dot(vTransformedNormal, normalize(uSpotLightLocation[i] - vPosition.xyz)), 0.0) / (length(uSpotLightLocation[i] - vPosition.xyz) * uSpotLightTheta[i]);
							// Specular
							if (uUseSpecular) {
								vec3 reflectionDirection = reflect(-normalize(uSpotLightLocation[i] - vPosition.xyz), vTransformedNormal);
								specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
							}
						}
						spotLightComponent += uSpotLightColor[i] * spotLightWeighting + uSpotLightColor[i] * specularLightWeighting;
					}
					// Directional Light - Does uLightDirecetion need to be normalised
					float directionalLightWeighting = max(dot(vTransformedNormal, uLightingDirection), 0.0);
					
					lightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + pointLightComponent + spotLightComponent;
				} 
				if(uUseTextures) {
					vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
					gl_FragColor = vec4(textureColor.rgb  * uColor.rgb * lightWeighting, textureColor.a);
				}
				else {
					gl_FragColor = vec4(uColor.rgb * lightWeighting, uColor.a);
				}
			}
		</script>
		<script id="pixel-shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			varying vec2 vTextureCoord;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			void main(void) {
				vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				gl_Position = uPMatrix * vPosition;
				vTextureCoord = aTextureCoord;
				vTransformedNormal = normalize(uNMatrix * aVertexNormal);
			}
		</script>
		<!-- Gremlin Engine -->
		<script type="text/javascript" src="Gremlin.js"></script>
		<!-- GUI : Note JQuery Depedency -->
		<script src="GUI.js"></script>
		<!-- Game Script -->
		<script src="game/game.js"></script>
		<style>
			html, body { margin: 0; padding: 0; overflow: hidden; font-family: monospace; }
			canvas { display: block; margin: 0 auto; /*cursor: url('data:image/gif;base64,R0lGODlhAQABAPAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto; */ cursor: crosshair; }
			/* CSS Styles*/
			#menuContainer { color: #FFF; margin: 0 auto; position: absolute; z-index: 100; }
			#menuContainer div.menu { margin: 0 2.5%; }
			#menuContainer ul { list-style: none; padding: 0; }
			#menuContainer ul li { margin: 0.5em 0;}
			#menuContainer ul li a { cursor: pointer; color: #FFF; }
			#menuContainer ul li a:hover { color: #46F; }
			#menuContainer a { color: #ACF; }
			#menuContainer select, #menuContainer input { background-color: #000; color: #FFF; border: none; font-size: 0.8em; font-family: monospace; }
			#menuContainer input[type=button] { margin: 0.5em 0; color: #ACF; cursor: pointer; }
			#menuContainer div.small { font-size: 0.5em; height: 80%; }
			#menuContainer div.small img { width: 10%; }
		</style>
	</head>
	<body onload="Game.webGLStart(1);">
		<div id="container">
			<div id="menuContainer" oncontextmenu="return false;">
				<!-- Main Menu -->
				<div gui-role="menu" gui-id="mainMenu" class="menu">
					<!--<h1>WebGL ZeroG</h1>-->
<pre>
 _____                 ___ 
/ _  / ___ _ __ ___   / _ \
\// / / _ \ '__/ _ \ / /_\/
 / //\  __/ | | (_) / /_\\ 
/____/\___|_|  \___/\____/ Alpha
</pre>
					<ul gui-role="links">
						<li><a gui-target="levelMenu">New Game</a></li>
						<li><a gui-target="optionsMenu">Options</a></li>
						<li><a gui-target="tutorialMenu">How to Play</a></li>
						<li><a gui-target="creditsMenu">Credits</a></li>
						<li><a gui-target="feedbackMenu">Feedback</a></li>
					</ul>
				</div>
				<!-- Tutorial Menu -->
				<div gui-role="menu" gui-id="tutorialMenu" class="menu">
					<h2>How to Play</h2>
					<div class="small">
						<p>ZeroG is a space shooter with slightly more realistic physics than your average!</p>
						<p>If you're moving you will carry on moving in that direction until you accelerate in the opposite! There is no top speed so if you're closing in on an object remember to leave enough time to decelerate or you'll just go straight past... or possibly collide.</p>
						<p>Talking of collisions, the damage recieved from them, both from bullets and other ships, is related to their relative velocities, so bear that in mind!</p>
						<p>WASD controls your acceleartion, Q and E roll your ship, right click turns your ship, and left click fires. Esc pauses the game.</p>
						<p>Have fun and leave feedback!</p>
					</div>
					<div>
						<input gui-role="navButton" gui-target="mainMenu" type="button" value="Cancel" />
					</div>
				</div>
				<!-- Options Menu -->
				<div gui-role="menu" gui-id="optionsMenu" class="menu">
					<h2>Options</h2>
					<form>
						<div>
							<label for="optionsResolution">Resolution</label>
							<input id="optionsResolution" type="range" class="range" min="0.1" max="1.0" step="0.1" value="1" />
							<span id="optionsResolutionOutput">1.0</span>
						</div>
						<div>
							<label for="optionsLighting">Lighting</label>
							<select id="optionsLighting">
								<option value="false">No Lighting</option>
								<option value="Vertex">Per Vertex</option>
								<option value="Pixel" selected>Per Pixel</option>
							</select>
						</div>
						<div>
							<label for="optionsSpecularLighting">Specular Lighting</label>
							<select id="optionsSpecularLighting">
								<option value="false" selected>Off</option>
								<option value="true">On</option>
							</select>
						</div>
						<div>
							<input gui-role="navButton" gui-target="mainMenu" type="button" value="Cancel" />
							<input gui-role="navButton applyOptions" gui-target="mainMenu" type="button" value="Okay" />
						</div>
					</form>
				</div>
				<!-- Level Menu -->
				<div gui-role="menu" gui-id="levelMenu" class="menu">
					<h2>Select Level</h2>
					<ul class="links">
						<!-- Add Game Start -->
						<li><a gui-role="navButton startGame" gui-target="pauseMenu" gui-level="2">Alone in Space</a>(except for a teapot)</li>
						<li><a gui-role="navButton startGame" gui-target="pauseMenu" gui-level="1">Deep Space</a>(evil spinning crates)</li>
					</ul>
					<input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" />
				</div>
				<!-- Credits Menu -->
				<div gui-role="menu" gui-id="creditsMenu" class="menu">
					<h2>Credits</h2>
					<div class="small">
						<img src="textures/delph.png" alt="delph" />
						<p>Game design and programming by <a target="_blank" href="http://twitter.com/_delph/">delph</a></p>
						<p>Powered by Gremlins</p>
						<p>Thanks To:</p>
						<p><a  target="_blank" href="http://twitter.com/#!/gpjt">gpjt</a> &amp; <a target="_blank" href="http://twitter.com/Tojiro">Tojiro</a></p>
					</div>
					<div><input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" /></div>
				</div>
				<!-- Feedback Menu -->
				<div gui-role="menu" gui-id="feedbackMenu" class="menu">
					<h2>Feedback</h2>
					<p>Please leave feedback on <a target="_blank" href="http://delphic.me.uk/zerog-webgl.html">my website</a> or message me <a href="http://www.twitter.com/_delph/">@_delph</a> on twitter.</p>
					<div><input gui-role="navButton" gui-target="mainMenu" type="button" value="Back" /></div>
				</div>
				<!-- Pause Menu -->
				<div gui-role="menu" gui-id="pauseMenu" class="menu">
					<h2>Paused</h2>
					<div>
						<div><input gui-role="resumeGame" type="button" value="Resume"/></div>
						<div><input gui-role="navButton menuResume" gui-target="mainMenu" id="btnPauseExit" type="button" value="Main Menu"/></div>
					</div>
				</div>
				<!-- End Game Menu -->
				<!-- TODO: Remove this and replace with in game HUD - press any key to continue - which will then spit you back to the main menu -->
				<div gui-role="menu" gui-id="endGameMenu" class="menu">
					<div id="endGameMessage"></div>
					<div>
						<div><input gui-role="navButton menuResume" gui-target="mainMenu" id="btnEndGameExit" type="button" value="Main Menu"/></div>
					</div>
				</div>
			</div>
			<canvas id="gremlinCanvas" oncontextmenu="return false;"></canvas>
		</div>
	</body>
</html>